/**
 * Bun Build Script for @resourcexjs/type
 * ESM-only modern build
 *
 * Steps:
 * 1. Bundle builtin types (text, json, binary) from source files
 * 2. Generate builtinTypes.ts with bundled code
 * 3. Build the package
 */

import { dts } from "bun-dts";
import { resolve } from "node:path";

const pkg = await Bun.file("./package.json").json();
const outdir = "./dist";

await Bun.$`rm -rf ${outdir}`;

console.log(`Building @resourcexjs/type v${pkg.version}\n`);

// Step 1: Bundle builtin types
console.log("Bundling builtin types...");

const builtinSources = [
  { name: "text", path: "./src/builtins/text.type.ts" },
  { name: "json", path: "./src/builtins/json.type.ts" },
  { name: "binary", path: "./src/builtins/binary.type.ts" },
];

const bundledTypes: { name: string; code: string; meta: any }[] = [];

for (const source of builtinSources) {
  const fullPath = resolve(import.meta.dir, source.path);

  // Bundle the source file
  const result = await Bun.build({
    entrypoints: [fullPath],
    target: "browser", // V8 compatible
    format: "esm",
    minify: false,
  });

  if (!result.success) {
    console.error(`Failed to bundle ${source.name}:`);
    for (const log of result.logs) console.error(log);
    process.exit(1);
  }

  const bundledCode = await result.outputs[0].text();

  // Import metadata from source
  const mod = await import(fullPath);
  const meta = mod.default;

  bundledTypes.push({
    name: source.name,
    code: bundledCode,
    meta,
  });

  console.log(`  - ${source.name}: bundled`);
}

// Step 2: Generate builtinTypes.ts
console.log("\nGenerating builtinTypes.ts...");

/**
 * Process ESM bundled code for sandbox execution.
 *
 * ESM bundled code format:
 * ```
 * var text_type_default = { ... };
 * export { text_type_default as default };
 * ```
 *
 * We need to:
 * 1. Remove the `export { ... };` statement
 * 2. Extract the variable name (e.g., `text_type_default`)
 *
 * Returns: { code: processedCode, varName: string }
 */
function processEsmBundle(bundledCode: string): { code: string; varName: string } {
  // Extract variable name from: export { X as default };
  const exportMatch = bundledCode.match(/export\s*\{\s*(\w+)\s+as\s+default\s*\}/);
  if (!exportMatch) {
    throw new Error("Could not find default export in bundled code");
  }
  const varName = exportMatch[1];

  // Remove the export statement
  const code = bundledCode.replace(/export\s*\{\s*\w+\s+as\s+default\s*\};\s*/g, "").trim();

  return { code, varName };
}

const builtinTypesContent = `/**
 * Built-in resource types (pre-bundled).
 * Auto-generated by build.ts - DO NOT EDIT
 *
 * Resolver code receives ResolveContext (ctx) with:
 * - ctx.manifest: { domain, path?, name, type, version }
 * - ctx.files: Record<string, Uint8Array>
 *
 * Code format: ESM bundled code (without export statement)
 * The resolver variable name is stored in the code comment.
 */

import type { BundledType } from "./types.js";

${bundledTypes
  .map((t) => {
    const { code, varName } = processEsmBundle(t.code);
    // Escape backticks and ${} in the code for template literal
    const escapedCode = code.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\$\{/g, "\\${");
    return `
/**
 * ${t.meta.description}
 */
export const ${t.name}Type: BundledType = {
  name: "${t.meta.name}",
  aliases: ${JSON.stringify(t.meta.aliases)},
  description: "${t.meta.description}",
  code: \`// @resolver: ${varName}
${escapedCode}\`,
};
`;
  })
  .join("\n")}

/**
 * All built-in types as an array.
 */
export const builtinTypes: BundledType[] = [textType, jsonType, binaryType];
`;

await Bun.write("./src/builtinTypes.ts", builtinTypesContent);
console.log("  - builtinTypes.ts generated");

// Step 3: Build the package
console.log("\nBuilding package...");

const result = await Bun.build({
  entrypoints: ["src/index.ts"],
  outdir,
  format: "esm",
  target: "node",
  sourcemap: "external",
  minify: false,
  plugins: [dts()],
  define: {
    __VERSION__: JSON.stringify(pkg.version),
  },
});

if (!result.success) {
  console.error("Build failed:");
  for (const log of result.logs) console.error(log);
  process.exit(1);
}

console.log(`\nBuild complete: ${result.outputs.length} files`);
