/**
 * Built-in resource types (pre-bundled).
 * Auto-generated by build.ts - DO NOT EDIT
 *
 * Resolver code receives ResolveContext (ctx) with:
 * - ctx.manifest: { domain, path?, name, type, tag }
 * - ctx.files: Record<string, Uint8Array>
 *
 * Code format: ESM bundled code (without export statement)
 * The resolver variable name is stored in the code comment.
 */

import type { BundledType } from "./types.js";

/**
 * Plain text content
 */
export const textType: BundledType = {
  name: "text",
  aliases: ["txt", "plaintext"],
  description: "Plain text content",
  code: `// @resolver: text_type_default
// src/builtins/text.type.ts
var text_type_default = {
  name: "text",
  aliases: ["txt", "plaintext"],
  description: "Plain text content",
  async resolve(ctx) {
    const content = ctx.files["content"];
    return new TextDecoder().decode(content);
  }
};`,
};

/**
 * JSON content
 */
export const jsonType: BundledType = {
  name: "json",
  aliases: ["config", "manifest"],
  description: "JSON content",
  code: `// @resolver: json_type_default
// src/builtins/json.type.ts
var json_type_default = {
  name: "json",
  aliases: ["config", "manifest"],
  description: "JSON content",
  async resolve(ctx) {
    const content = ctx.files["content"];
    return JSON.parse(new TextDecoder().decode(content));
  }
};`,
};

/**
 * Binary content
 */
export const binaryType: BundledType = {
  name: "binary",
  aliases: ["bin", "blob", "raw"],
  description: "Binary content",
  code: `// @resolver: binary_type_default
// src/builtins/binary.type.ts
var binary_type_default = {
  name: "binary",
  aliases: ["bin", "blob", "raw"],
  description: "Binary content",
  async resolve(ctx) {
    return ctx.files["content"];
  }
};`,
};

/**
 * Skill content (SKILL.md + optional references)
 */
export const skillType: BundledType = {
  name: "skill",
  aliases: ["agent-skill"],
  description: "Agent skill package with SKILL.md and optional references",
  code: `// @resolver: skill_type_default
// skill type resolver
var skill_type_default = {
  name: "skill",
  aliases: ["agent-skill"],
  description: "Agent skill package with SKILL.md and optional references",
  async resolve(ctx, args) {
    const skillFile = ctx.files["SKILL.md"];
    if (!skillFile) {
      throw new Error("Skill resource must contain a SKILL.md file");
    }
    const decoder = new TextDecoder();
    const content = decoder.decode(skillFile);
    if (args && args.reference) {
      const refPath = "references/" + args.reference;
      const refFile = ctx.files[refPath];
      if (!refFile) {
        const available = Object.keys(ctx.files).filter(k => k.startsWith("references/")).map(k => k.replace("references/", ""));
        throw new Error("Reference not found: " + args.reference + ". Available: " + available.join(", "));
      }
      return decoder.decode(refFile);
    }
    return content;
  }
};`,
  schema: {
    type: "object",
    properties: {
      reference: {
        type: "string",
        description: "Optional reference file name to load instead of SKILL.md",
      },
    },
  },
};

/**
 * Prototype instruction set (prototype.json + @filename references)
 */
export const prototypeType: BundledType = {
  name: "prototype",
  description: "Instruction set for materializing roles and organizations",
  code: `// @resolver: prototype_type_default
var prototype_type_default = {
  async resolve(ctx) {
    var protoFile = ctx.files["prototype.json"];
    if (!protoFile) throw new Error("Prototype resource must contain a prototype.json file");
    var decoder = new TextDecoder();
    var instructions = JSON.parse(decoder.decode(protoFile));
    if (!Array.isArray(instructions)) {
      throw new Error("prototype.json must be a JSON array of instructions");
    }
    var resolved = instructions.map(function(instr) {
      var resolvedArgs = {};
      var keys = Object.keys(instr.args || {});
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = instr.args[key];
        if (typeof value === "string" && value.startsWith("@")) {
          var filename = value.slice(1);
          var file = ctx.files[filename];
          if (!file) throw new Error("Referenced file not found: " + filename);
          resolvedArgs[key] = decoder.decode(file);
        } else {
          resolvedArgs[key] = value;
        }
      }
      return { op: instr.op, args: resolvedArgs };
    });
    return { id: ctx.manifest.name, instructions: resolved };
  }
};`,
};

/**
 * All built-in types as an array.
 */
export const builtinTypes: BundledType[] = [
  textType,
  jsonType,
  binaryType,
  skillType,
  prototypeType,
];
