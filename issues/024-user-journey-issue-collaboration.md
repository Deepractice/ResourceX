# User Journey 驱动的 ISSUE 协作模式

## 概述

这是一个**边讨论边实现**的敏捷协作模式，用于推进产品功能迭代。

**核心理念**：

- **不是传统Issue** - 不是先创建待办事项再实现，而是在对话中边讨论边实现
- **User Journey驱动** - 以用户旅程为主线，确保功能闭环
- **ISSUE方法论** - 使用友好的Socratic对话推进问题，提供建议降低认知负担
- **持续迭代** - 不停止，直到这个Journey完整可用

**适用场景**：

- 基础架构已完成，需要快速迭代功能
- 需要明确用户价值和使用路径
- 需要在讨论中发现问题并即时解决

---

## 与传统模式的区别

### 传统模式（不是我们要的）

```
1. 创建Issue → 2. 讨论需求 → 3. 关闭讨论 → 4. 开始实现 → 5. 更新Issue
       ↑                                                      ↓
       └──────────────────────────────────────────────────────┘
                          （讨论和实现分离）
```

**问题**：

- 讨论时没有代码验证，容易空谈
- 实现时忘记讨论的细节
- Issue变成文档堆积

### ISSUE协作模式（我们要的）

```
┌─────────────────────────────────────────────────────────────┐
│  在对话中同时进行：                                          │
│                                                             │
│    讨论问题 ←→ 写代码 ←→ 验证 ←→ 调整 ←→ 继续讨论           │
│         ↓         ↓        ↓        ↓         ↓            │
│         └─────────┴────────┴────────┴─────────┘            │
│                          │                                  │
│                          ↓                                  │
│              Journey闭环完成后记录到Issue                    │
└─────────────────────────────────────────────────────────────┘
```

**优势**：

- 讨论到哪里就实现到哪里，即时验证
- 在实现过程中发现新问题，立即讨论解决
- 最终的Issue是完整的Journey记录，不是待办事项

---

## ISSUE 方法论详解

ISSUE = **I**nitiate + **S**tructure + **S**ocratic + **U**nify + **E**xecute

### 1. Initiate（发起议题）

用户提出**明确的议题**，不是模糊的需求。

**好的议题**：

- "开发者如何发布一个Resource到Registry"
- "用户如何在Registry发现并安装一个Prompt"
- "如何让Agent能够自动发现和使用Resource"

**不好的议题**：

- "完善Registry功能" （太模糊）
- "优化用户体验" （没有具体方向）

### 2. Advice Structure（建议框架）

AI**主动**建议适合的分析框架，**必须提供选项**，降低用户认知负担。

```markdown
"基于这个议题，我建议以下框架：

**选项A：[名称]**

- 适用场景：...
- 优势：...
- 涉及功能：...

**选项B：[名称]**

- 适用场景：...
- 优势：...
- 涉及功能：...

**选项C：[名称]**

- 适用场景：...
- 优势：...
- 涉及功能：...

您想选择哪个，或有其他偏好？"
```

**关键要求**：

- **必须提供Advice** - 不能只问问题，要给建议
- **3-5个选项** - 不能太少（没有选择），不能太多（信息过载）
- **永远有"其他"选项** - 保持开放性

### 3. Structure（确定框架）

用户选择或提供框架后，建立认知脚手架。

这一步确定：

- User Journey的起点和终点
- 涉及的系统组件
- 实现的优先级

### 4. Friendly Advice Socratic（友好探索）

**这是核心步骤** - 用友好的对话方式深入探索问题。

#### 核心特征

| 特征           | 说明             | 示例                         |
| -------------- | ---------------- | ---------------------------- |
| **共情式开场** | 用轻松的语气开始 | "咱们先看看..."、"我理解..." |
| **渐进式深入** | 从简单到复杂     | 先问大方向，再问细节         |
| **确认式推进** | 确认理解后再继续 | "你刚才提到...，那么..."     |
| **选择式引导** | 提供选项供参考   | "常见的做法有A、B、C..."     |
| **总结式过渡** | 阶段性总结       | "明白了，那我们再看看..."    |

#### Advice示例

```markdown
"用户在Registry搜索资源时，最关心什么？

常见的关注点包括：
A) 资源的功能描述是否清晰
B) 下载量/使用量（社区验证）
C) 最近更新时间（是否活跃维护）
D) 作者信誉度
E) 其他？"
```

#### 单点聚焦原则

**每次只问一个核心问题**，避免问题轰炸。

```markdown
# 不好的做法（问题轰炸）

"搜索功能需要支持哪些过滤器？排序怎么做？
分页用什么方案？要不要支持模糊搜索？"

# 好的做法（单点聚焦）

"咱们先确定搜索的核心场景。用户搜索时，
最常见的需求是什么？

A) 按类型过滤（prompt/tool/agent）
B) 按关键词匹配
C) 按作者/组织过滤
D) 其他？"
```

#### 边讨论边实现

**关键区别**：讨论到某个点时，如果可以实现，立即实现。

```markdown
# 对话示例

AI: "那我们先实现按类型过滤，目前Registry-web需要调用
/api/v1/search?type=prompt 这样的接口，我来添加这个功能..."

[AI 实现代码]

AI: "已经实现了类型过滤。现在咱们看下一个问题：
排序功能，你觉得默认按什么排序比较好？

     A) 最新发布优先
     B) 下载量高优先
     C) 相关度优先
     D) 其他？"
```

### 5. Unify（统一方案）

在探索过程中不断整合，形成一致的方案。

**不是等探索完再统一**，而是**边探索边统一**：

- 每解决一个问题，就更新整体方案
- 发现矛盾时，立即讨论解决
- 保持方案的一致性

### 6. Execute（执行计划）

具体可执行的步骤已经在对话中完成了大部分。

这一步是：

- 确认所有功能都已实现
- 验证User Journey可以跑通
- 记录到GitHub Issue作为文档

---

## User Journey 结构

### Journey 定义模板

```markdown
## Journey: [名称]

### 用户角色

[谁在使用这个功能]

### 起点

[用户的初始状态]

### 终点

[用户完成后的状态]

### 关键步骤

1. [步骤1] - [涉及的功能模块]
2. [步骤2] - [涉及的功能模块]
3. ...

### 成功标准

- [ ] 用户可以 [做什么]
- [ ] 系统会 [表现什么]
```

### Journey 示例

```markdown
## Journey: Developer Publishing a Resource

### 用户角色

想要分享自己Prompt的开发者

### 起点

开发者本地有一个写好的Prompt文件

### 终点

Prompt已发布到Registry，其他人可以搜索和安装

### 关键步骤

1. 创建resource.json元数据 - [loader]
2. 使用CLI打包并发布 - [cli, registry-api]
3. 在Registry-web上查看 - [registry-web]
4. 其他用户可以搜索到 - [registry-api]

### 成功标准

- [ ] 开发者可以用一条命令发布资源
- [ ] 发布后立即在搜索结果中出现
- [ ] 资源详情页显示完整信息
```

---

## 完整协作流程

```
┌─────────────────────────────────────────────────────────────┐
│  Step 1: Initiate - 用户提出Journey议题                      │
│          "我们来做开发者发布Resource的Journey"               │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│  Step 2: Advice Structure - AI建议框架                       │
│          "这个Journey可以从三个角度切入：A/B/C，你选哪个？"    │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│  Step 3: Structure - 确定Journey范围                         │
│          确定起点、终点、关键步骤                             │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│  Step 4: Friendly Advice Socratic - 边讨论边实现             │
│                                                             │
│   ┌──────────────────────────────────────────────────────┐  │
│   │  4.1 讨论第一个步骤                                   │  │
│   │      AI: "CLI命令设计，你倾向于A还是B？"              │  │
│   │      用户: "A"                                       │  │
│   │      AI: "好，我来实现..." [写代码]                   │  │
│   │      AI: "完成了，咱们看下一个问题..."                │  │
│   └──────────────────────────────────────────────────────┘  │
│                          ↓                                  │
│   ┌──────────────────────────────────────────────────────┐  │
│   │  4.2 讨论第二个步骤                                   │  │
│   │      ...                                             │  │
│   └──────────────────────────────────────────────────────┘  │
│                          ↓                                  │
│   ┌──────────────────────────────────────────────────────┐  │
│   │  4.N 讨论第N个步骤                                    │  │
│   │      ...                                             │  │
│   └──────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│  Step 5: Unify - 验证Journey闭环                            │
│          从头走一遍，确认所有步骤都能跑通                      │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│  Step 6: Execute - 记录到GitHub Issue                       │
│          把整个Journey（对话+决策+代码）记录下来              │
└─────────────────────────────────────────────────────────────┘
```

---

## 协作约束（必须遵守）

### 强制要求

| 约束                  | 说明                           |
| --------------------- | ------------------------------ |
| **Friendly Socratic** | 必须友好对话，不能生硬提问     |
| **Advice Structure**  | 必须提供框架建议，不能只问不答 |
| **单点聚焦**          | 每次只问一个核心问题           |
| **开放性选项**        | 永远提供"其他"选项             |
| **边做边讨论**        | 讨论到可实现时立即实现         |

### 禁止行为

| 禁止                       | 替代做法           |
| -------------------------- | ------------------ |
| 问题轰炸（一次问多个问题） | 拆分成多轮对话     |
| 只问不建议                 | 必须提供Advice选项 |
| 讨论完再实现               | 边讨论边实现       |
| 生硬的技术语言             | 用友好的对话语气   |

---

## 质量标准

| 维度                | 检查项                          |
| ------------------- | ------------------------------- |
| **议题明确度**      | Issue是否清晰定义了User Journey |
| **Structure适配度** | 框架与议题的匹配程度            |
| **对话友好度**      | Socratic过程是否友好自然        |
| **Advice价值度**    | 建议选项是否实用                |
| **实现完整度**      | Journey是否可以完整跑通         |
| **文档清晰度**      | Issue记录是否清晰可追溯         |

---

## 与000-unified-development-mode的关系

| 模式                             | 适用场景               | 侧重点                             |
| -------------------------------- | ---------------------- | ---------------------------------- |
| **000-unified-development-mode** | 功能开发（有明确需求） | Code Review + BDD + TDD            |
| **024-user-journey-issue**       | 产品迭代（需要探索）   | User Journey + 友好对话 + 边做边改 |

**可以结合使用**：

1. 用024模式确定要做什么（User Journey）
2. 用000模式实现具体功能（BDD驱动）

---

## 快速参考

### 启动一个Journey

```markdown
"我们来做[用户角色]的[具体场景]Journey"
```

### AI响应模板

```markdown
"好的，咱们来看看[Journey名称]。

基于这个Journey，我建议从这几个角度切入：

**选项A：[名称]**
[描述]

**选项B：[名称]**
[描述]

**选项C：[名称]**
[描述]

你倾向于哪个，或者有其他想法？"
```

### 单点问题模板

```markdown
"[共情开场]，咱们来看看[具体问题]。

常见的做法有：
A) [选项A]
B) [选项B]
C) [选项C]
D) 其他？

[可选：我倾向于X，因为...]"
```

### Journey完成检查

```markdown
- [ ] 所有关键步骤都已实现
- [ ] 从起点到终点可以完整跑通
- [ ] 用户体验流畅，没有阻塞点
- [ ] 边界情况已处理
- [ ] 记录到GitHub Issue
```

---

## 示例：ResourceX的核心Journey

### Journey 1: Developer Publishing

开发者发布一个Resource到Registry

### Journey 2: Developer Discovery

开发者发现并安装一个Resource

### Journey 3: Agent Integration

Agent自动发现和使用Resource

### Journey 4: Organization Management

组织管理其发布的Resources

---

## 相关文件

- `issues/000-unified-development-mode.md` - 功能开发模式
- `bdd/features/` - BDD测试用例
- `services/registry-web/` - Registry前端
- `services/registry-api/` - Registry API
